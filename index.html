<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Interactive Website - Screen Sharing & Models</title>
  <meta name="description" content="Interactive 3D environment with screen sharing, GLB model loading, and object manipulation">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0; /* Research shows this is critical for mobile */
      overflow: hidden;
      font-family: 'Courier New', monospace;
      background: #000;
      color: #00ff00;
    }

    #scene-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    
    /* Research-backed mobile canvas styles */
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none; /* Prevents scrolling on touch */
    }

    .screen {
      position: absolute;
      width: 320px;
      height: 240px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #00ff00;
      border-radius: 8px;
      padding: 20px;
      z-index: 100;
      backdrop-filter: blur(5px);
      cursor: pointer;
    }

    .screen h2 {
      color: #00ff00;
      margin-bottom: 15px;
      text-align: center;
      font-size: 18px;
    }

    .terminal-content {
      font-size: 14px;
      line-height: 1.5;
    }

    .terminal-content p {
      margin-bottom: 8px;
    }

    .controls-info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 200;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 5px;
      border: 1px solid #00ff00;
      font-size: 12px;
    }

    .controls-info p {
      margin-bottom: 5px;
      color: #00ff00;
    }

    .model-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 200;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 5px;
      border: 1px solid #00ff00;
      font-size: 12px;
      display: none;
    }

    .model-controls.visible {
      display: block;
    }

    .model-controls button {
      background: transparent;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 5px 10px;
      margin: 2px;
      border-radius: 3px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 10px;
    }

    .model-controls button:hover {
      background: rgba(0, 255, 0, 0.2);
    }

    .screen-controls {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 200;
      background: rgba(0, 0, 0, 0.9);
      padding: 8px;
      border-radius: 3px;
      border: 1px solid #00ff00;
      font-size: 10px;
      width: 180px;
    }

    .screen-controls h3 {
      color: #00ff00;
      margin: 0 0 5px 0;
      font-size: 11px;
    }

    .screen-controls button {
      background: transparent;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 4px 6px;
      margin: 1px;
      border-radius: 2px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 9px;
      width: 100%;
    }

    .screen-controls button:hover {
      background: rgba(0, 255, 0, 0.2);
    }

    .screen-controls input[type="file"] {
      background: transparent;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 2px;
      margin: 1px 0;
      border-radius: 2px;
      font-family: 'Courier New', monospace;
      font-size: 8px;
      width: 100%;
    }

    .screen-controls input[type="file"]::-webkit-file-upload-button {
      background: transparent;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 2px 4px;
      border-radius: 2px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 8px;
    }

    .screen-controls input[type="range"] {
      appearance: none;
      background: transparent;
      cursor: pointer;
      height: 15px;
    }

    .screen-controls input[type="range"]::-webkit-slider-track {
      background: #00ff00;
      height: 3px;
      border-radius: 2px;
    }

    .screen-controls input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      background: #00ff00;
      height: 12px;
      width: 12px;
      border-radius: 50%;
      cursor: pointer;
      margin-top: -4px;
    }

    .room-controls {
      position: absolute;
      top: 20px;
      left: 220px;
      z-index: 200;
      background: rgba(0, 0, 0, 0.9);
      padding: 8px;
      border-radius: 3px;
      border: 1px solid #ffaa00;
      font-size: 10px;
      width: 200px;
    }

    .room-controls h3 {
      color: #ffaa00;
      margin: 0 0 5px 0;
      font-size: 11px;
    }

    .room-controls button {
      background: transparent;
      border: 1px solid #ffaa00;
      color: #ffaa00;
      padding: 4px 6px;
      margin: 1px;
      border-radius: 2px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 9px;
      width: 100%;
    }

    .room-controls button:hover {
      background: rgba(255, 170, 0, 0.2);
    }

    .room-controls input[type="text"] {
      background: transparent;
      border: 1px solid #ffaa00;
      color: #ffaa00;
      padding: 4px;
      margin: 2px 0;
      border-radius: 2px;
      font-family: 'Courier New', monospace;
      font-size: 9px;
      width: 100%;
    }

    .room-status {
      margin-top: 5px;
      font-size: 8px;
      color: #ffaa88;
    }

    .room-status.connected {
      color: #88ffaa;
    }

    .room-status.error {
      color: #ff8888;
    }

    #video-element {
      display: none;
    }

    .drag-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 255, 0, 0.1);
      border: 3px dashed #00ff00;
      z-index: 300;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: #00ff00;
      pointer-events: none;
    }

    .drag-overlay.active {
      display: flex;
    }

    canvas {
      display: block;
    }

    @media (max-width: 768px) {
      .screen {
        width: 280px;
        height: 200px;
        padding: 15px;
      }
      
      .controls-info {
        bottom: 10px;
        left: 10px;
        right: 10px;
        font-size: 11px;
      }
      
      .screen-controls {
        width: 160px;
        font-size: 9px;
      }
    }
  </style>
</head>
<body>
  <div id="scene-container">
    <div class="screen" id="interactive-screen">
      <h2>3D Model Loader</h2>
      <div class="terminal-content">
        <p>üñ•Ô∏è Large screen sharing available!</p>
        <p>üì¶ Drag & drop GLB files here!</p>
        <p>Click to enter or press ENTER</p>
        <p>WASD to move, mouse to look</p>
      </div>
    </div>
    <div class="drag-overlay" id="drag-overlay">
      <div>Drop GLB file to load 3D model</div>
    </div>
  </div>
  
  <div class="controls-info">
    <p>Click objects to select | Drag GLB files to load</p>
    <p>WASD: move | Mouse: look | ENTER: hide screen</p>
    <p>R: reset | Q: rotate | E/C: scale | DEL: delete</p>
  </div>
  
  <div class="screen-controls" id="screen-controls">
    <h3>üì∫ Large Screen Controls</h3>
    <button id="share-screen">üñ•Ô∏è Share Desktop Screen</button>
    <button id="stop-sharing">‚èπÔ∏è Stop Sharing</button>
    <input type="file" id="video-upload" accept="video/*" />
    <button id="load-video">üìÅ Load Video File</button>
    <button id="clear-screen">üßπ Clear Screen</button>
    <div style="margin-top: 5px;">
      <button id="toggle-audio">üîä Audio ON</button>
      <input type="range" id="volume-slider" min="0" max="100" value="100" style="width: 60px; margin-left: 5px;">
    </div>
    <div style="margin-top: 5px; font-size: 8px; color: #00ff88;">
      <p style="margin: 2px 0;">Screen in 3D scene</p>
      <p style="margin: 2px 0;">Click to move/resize</p>
    </div>
  </div>

  
  <video id="video-element" autoplay controls muted="false" volume="1.0" style="display: none;"></video>
  
  <div class="model-controls" id="model-controls">
    <h3 id="selected-object-name">Object Controls</h3>
    <div>
      <button id="move-up">‚Üë Up</button>
      <button id="move-down">‚Üì Down</button>
      <button id="move-left">‚Üê Left</button>
      <button id="move-right">‚Üí Right</button>
    </div>
    <div>
      <button id="move-forward">‚ñ≤ Forward</button>
      <button id="move-backward">‚ñº Backward</button>
      <button id="scale-up">+ Scale</button>
      <button id="scale-down">- Scale</button>
    </div>
    <div>
      <button id="rotate-y">‚Üª Rotate</button>
      <button id="reset-object">‚ü≤ Reset</button>
      <button id="delete-selected" style="background: rgba(255, 0, 0, 0.2); border-color: #ff0000; color: #ff0000;">üóë Delete</button>
    </div>
    <div>
      <button id="deselect-object">‚úñ Deselect</button>
    </div>
  </div>
  
  <script src="https://unpkg.com/socket.io-client@4.7.2/dist/socket.io.js"></script>
  <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

    console.log('Starting 3D Interactive Website...');

    // Enhanced mobile detection - define FIRST
    const isMobileEarly = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // Scene setup
    const scene = new THREE.Scene();
    // Test if we can see ANY background on mobile - use bright color for debugging
    if (isMobileEarly) {
      scene.background = new THREE.Color(0x222222); // Darker gray for mobile visibility test
    } else {
      scene.background = new THREE.Color(0x000011); // Original dark blue for desktop
    }

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const isIOSNew = /iPhone|iPad/.test(navigator.userAgent) && parseFloat(navigator.userAgent.match(/OS (\d+)/)?.[1] || '0') >= 17;
    
    // Test WebGL context creation first
    let webglTestCanvas = document.createElement('canvas');
    let testGL = null;
    let webglSupported = false;
    let highpSupported = false;
    
    try {
      testGL = webglTestCanvas.getContext('webgl') || webglTestCanvas.getContext('experimental-webgl');
      if (testGL) {
        webglSupported = true;
        // Test shader precision support
        const fragmentShaderPrecision = testGL.getShaderPrecisionFormat(testGL.FRAGMENT_SHADER, testGL.HIGH_FLOAT);
        highpSupported = fragmentShaderPrecision && fragmentShaderPrecision.precision > 0;
        console.log('WebGL supported:', webglSupported, 'Highp supported:', highpSupported);
      }
    } catch (e) {
      console.error('WebGL context creation failed:', e);
    } finally {
      if (testGL) {
        // Clean up test context to avoid context limit issues
        const loseContextExt = testGL.getExtension('WEBGL_lose_context');
        if (loseContextExt) loseContextExt.loseContext();
      }
      webglTestCanvas = null;
      testGL = null;
    }
    
    if (!webglSupported) {
      document.body.innerHTML = '<div style="color: white; text-align: center; margin-top: 50px;">WebGL not supported on this device</div>';
      throw new Error('WebGL not supported');
    }
    
    // Create renderer with mobile-optimized settings based on research
    const renderer = new THREE.WebGLRenderer({ 
      antialias: false, // Disable on all devices to avoid mobile issues
      alpha: false, // CRITICAL: Research shows alpha: true causes mobile white screens
      powerPreference: "high-performance", // Research shows this helps with multiple GPUs
      preserveDrawingBuffer: true, // Required for some mobile browsers
      failIfMajorPerformanceCaveat: false,
      stencil: false, // Disable stencil buffer to save memory
      depth: true,
      logarithmicDepthBuffer: false // Can cause issues on some mobile GPUs
    });
    
    // Conservative sizing for mobile
    const maxSize = isMobileEarly ? 1024 : 2048;
    const actualWidth = Math.min(window.innerWidth, maxSize);
    const actualHeight = Math.min(window.innerHeight, maxSize);
    
    renderer.setSize(actualWidth, actualHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Research-backed pixel ratio handling
    
    // Essential renderer settings based on mobile compatibility research
    renderer.outputColorSpace = THREE.SRGBColorSpace; // Use standard sRGB, not Linear
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.sortObjects = false; // Disable sorting for performance
    renderer.shadowMap.enabled = false; // Always disable shadows
    
    // CRITICAL: Set clear color only if no scene background (research-backed fix)
    if (!scene.background) {
      renderer.setClearColor(0x000000, 1); // Black background, full opacity
    }
    
    console.log('Mobile-optimized renderer created');
    
    // Shadow map setup will be handled in lighting section based on device type
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Add context loss/restore handling before appending to DOM
    const canvas = renderer.domElement;
    canvas.addEventListener('webglcontextlost', function(event) {
      event.preventDefault();
      console.warn('WebGL context lost - attempting recovery');
      // Stop animation loop
      if (window.animationId) {
        cancelAnimationFrame(window.animationId);
      }
    }, false);
    
    canvas.addEventListener('webglcontextrestored', function(event) {
      console.log('WebGL context restored - reinitializing');
      // Force page reload on context restore for now (simplest recovery)
      window.location.reload();
    }, false);
    
    // Set canvas style for mobile compatibility (research-backed)
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.touchAction = 'none'; // CRITICAL: Prevents scrolling on touch (research-backed)
    
    document.getElementById('scene-container').appendChild(canvas);

    // Detect mobile devices
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    console.log('Mobile device detected:', isMobile);
    
    // Check WebGL capabilities and renderer info
    const gl = renderer.getContext();
    console.log('=== DEVICE INFO ===');
    console.log('User Agent:', navigator.userAgent);
    console.log('Mobile detected:', isMobile);
    console.log('Device pixel ratio:', window.devicePixelRatio);
    console.log('=== WEBGL INFO ===');
    console.log('WebGL version:', gl.getParameter(gl.VERSION));
    console.log('WebGL vendor:', gl.getParameter(gl.VENDOR));
    console.log('WebGL renderer:', gl.getParameter(gl.RENDERER));
    console.log('Max texture size:', gl.getParameter(gl.MAX_TEXTURE_SIZE));
    console.log('WebGL context valid:', !gl.isContextLost());
    console.log('Renderer info:', renderer.info);
    
    // CRITICAL: Research-backed context debugging
    console.log('=== RENDERER DEBUG ===');
    console.log('Renderer context:', !!renderer.getContext());
    console.log('Canvas size:', renderer.domElement.width, 'x', renderer.domElement.height);
    console.log('Canvas style size:', renderer.domElement.style.width, 'x', renderer.domElement.style.height);
    console.log('Pixel ratio:', renderer.getPixelRatio());
    // Skip getClearColor() as it's causing errors
    console.log('Clear color: (skipped due to error)');
    console.log('=== SCENE INFO ===');
    console.log('Scene background:', scene.background);

    // Post-processing setup for subtle bloom effect (desktop only)
    let composer = null;
    if (!isMobile) {
      composer = new EffectComposer(renderer);
      
      // Basic render pass
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);
      
      // Bloom pass - very subtle
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.15,   // strength (very subtle)
        0.4,    // radius  
        0.95    // threshold (high = less blooming)
      );
      composer.addPass(bloomPass);
      
      // Output pass for proper color space
      const outputPass = new OutputPass();
      composer.addPass(outputPass);
      
      console.log('Bloom post-processing enabled for desktop');
    } else {
      console.log('Using direct rendering for mobile compatibility');
    }

    // Ultra-simple lighting for maximum mobile compatibility
    const ambientLight = new THREE.AmbientLight(0xffffff, isMobile ? 2.0 : 0.3);
    scene.add(ambientLight);

    // Minimal directional light for mobile
    const directionalLight = new THREE.DirectionalLight(0xffffff, isMobile ? 0.2 : 0.8);
    directionalLight.position.set(5, 5, 5);
    
    // Disable shadows on mobile for better performance and compatibility
    if (!isMobile) {
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      renderer.shadowMap.enabled = true;
    } else {
      renderer.shadowMap.enabled = false;
      console.log('Shadows disabled for mobile compatibility');
    }
    
    scene.add(directionalLight);
    
    console.log('=== LIGHTING INFO ===');
    console.log('Ambient light intensity:', ambientLight.intensity);
    console.log('Directional light intensity:', directionalLight.intensity);
    console.log('Shadows enabled:', renderer.shadowMap.enabled);

    // Initialize object management variables first
    let sceneObjects = [];
    let selectedObject = null;
    let isScreenVisible = true;
    
    // Selection system
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedOutline = null;


    // Add floor - use basic material on mobile for better compatibility
    const floorGeometry = new THREE.PlaneGeometry(20, 20);
    const floorMaterial = isMobile 
      ? new THREE.MeshBasicMaterial({ color: 0x333333 })
      : new THREE.MeshLambertMaterial({ color: 0x333333 });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -3;
    if (!isMobile) floor.receiveShadow = true;
    scene.add(floor);
    



    // Create canvas texture for screen content - mobile-optimized sizes
    function createScreenTexture() {
      const canvas = document.createElement('canvas');
      // Use much smaller textures on mobile to avoid GPU memory issues
      if (isMobile) {
        canvas.width = 512;  // Much smaller for mobile
        canvas.height = 288; // Maintain 16:9 ratio
      } else {
        canvas.width = 1920;
        canvas.height = 1080;
      }
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = '#001122';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#00ff00';
      
      // Scale font sizes based on canvas size for mobile compatibility
      const scale = canvas.width / 1920; // Scale relative to desktop size
      
      ctx.font = `bold ${Math.floor(72 * scale)}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText('LARGE DISPLAY SCREEN', canvas.width/2, canvas.height/2 - Math.floor(80 * scale));
      ctx.font = `bold ${Math.floor(48 * scale)}px Arial`;
      ctx.fillText('Ready for Screen Sharing or Video', canvas.width/2, canvas.height/2 + Math.floor(10 * scale));
      ctx.font = `${Math.floor(32 * scale)}px Arial`;
      ctx.fillText('Use controls to share desktop or load video', canvas.width/2, canvas.height/2 + Math.floor(80 * scale));
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      
      // Fix upside down texture orientation
      texture.flipY = false;
      
      // Fix mirrored/reversed texture (flip horizontally)
      texture.wrapS = THREE.RepeatWrapping;
      texture.repeat.x = -1;
      texture.offset.x = 1;
      
      return { texture: texture, canvas: canvas };
    }

    // Load the room model and setup SHARESCREEN object
    let largeScreen = null;
    
    function loadRoomModel() {
      loader.load('./models/BAKE-WEBROOM1.glb', function(gltf) {
        console.log('Loading room model...');
        const roomModel = gltf.scene;
        
        // Add the entire room to the scene
        roomModel.position.set(0, 0, 0);
        roomModel.scale.set(1, 1, 1);
        
        // Enable shadows for all meshes (desktop only)
        roomModel.traverse((child) => {
          if (child.isMesh) {
            if (!isMobile) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
            // Ensure materials are compatible with mobile
            if (child.material && isMobile) {
              // Fix texture loading on mobile - preserve original textures
              if (child.material.map) {
                // Ensure texture uses correct color space
                child.material.map.colorSpace = THREE.SRGBColorSpace;
                child.material.map.needsUpdate = true;
              }
              
              // Only replace material if it's causing issues
              if (child.material.type === 'MeshStandardMaterial' || child.material.type === 'MeshPhysicalMaterial') {
                const basicMaterial = new THREE.MeshBasicMaterial({
                  map: child.material.map, // CRITICAL: Preserve the texture map
                  color: child.material.map ? 0xffffff : (child.material.color || 0xffffff), // White if textured
                  transparent: child.material.transparent || false,
                  opacity: child.material.opacity || 1.0,
                  side: child.material.side || THREE.FrontSide
                });
                child.material = basicMaterial;
                console.log('Replaced material with MeshBasicMaterial, preserved texture:', !!child.material.map);
              }
              
              child.material.needsUpdate = true;
            }
          }
        });
        
        scene.add(roomModel);
        
        // Find the SHARESCREEN object
        let shareScreenObject = null;
        console.log('Searching for SHARESCREEN object in model...');
        roomModel.traverse((child) => {
          if (child.name) {
            console.log('Found object:', child.name, 'Type:', child.type, 'isMesh:', child.isMesh);
            if (child.name === 'SHARESCREEN' || child.name === 'SHARESCREEN-HERE' || child.name.toLowerCase().includes('sharescreen')) {
              shareScreenObject = child;
              console.log('‚úì Found SHARESCREEN object:', child.name, child);
            }
          }
        });
        
        console.log('SHARESCREEN search complete. Found:', shareScreenObject ? 'YES' : 'NO');
        
        if (shareScreenObject) {
          // Create screen texture
          const screenTexture = createScreenTexture();
          
          // Apply the texture to the SHARESCREEN object
          console.log('Applying texture to SHARESCREEN object...');
          console.log('Material:', shareScreenObject.material);
          console.log('Material type:', shareScreenObject.material ? shareScreenObject.material.type : 'none');
          
          // Create a new material specifically for screen content  
          const screenMaterial = new THREE.MeshBasicMaterial({ 
            map: screenTexture.texture,
            transparent: false,
            side: THREE.DoubleSide
          });
          
          // Ensure texture color space is correct
          screenTexture.texture.colorSpace = THREE.SRGBColorSpace;
          
          shareScreenObject.material = screenMaterial;
          shareScreenObject.material.needsUpdate = true;
          shareScreenObject.visible = true;
          
          console.log('‚úì Applied new MeshBasicMaterial with screen texture');
          console.log('Texture size:', screenTexture.canvas.width, 'x', screenTexture.canvas.height);
          
          // Set up largeScreen object to work with existing code
          largeScreen = {
            screen: shareScreenObject,
            texture: screenTexture.texture,
            canvas: screenTexture.canvas
          };
          
          shareScreenObject.userData = {
            name: 'Large Display Screen',
            type: 'display',
            originalPosition: shareScreenObject.position.clone(),
            originalScale: shareScreenObject.scale.clone(),
            originalRotation: shareScreenObject.rotation.clone()
          };
          
          sceneObjects.push(shareScreenObject);
          console.log('SHARESCREEN object configured successfully');
        } else {
          console.warn('SHARESCREEN object not found in model, creating fallback screen');
          createFallbackScreen();
        }
        
        console.log('Room model loaded successfully');
      }, 
      function(progress) {
        console.log('Room loading progress:', (progress.loaded / progress.total * 100) + '%');
      },
      function(error) {
        console.error('Error loading room model:', error);
        console.log('Creating fallback screen instead');
        createFallbackScreen();
      });
    }
    
    // Fallback screen creation if GLB fails to load
    function createFallbackScreen() {
      const screenWidth = 16;
      const screenHeight = 9;
      const screenTexture = createScreenTexture();
      
      const screenGeometry = new THREE.PlaneGeometry(screenWidth, screenHeight);
      const screenMaterial = new THREE.MeshBasicMaterial({ 
        map: screenTexture.texture,
        transparent: false
      });
      
      // Ensure texture color space is correct
      screenTexture.texture.colorSpace = THREE.SRGBColorSpace;
      
      const displayScreen = new THREE.Mesh(screenGeometry, screenMaterial);
      displayScreen.position.set(0, 4.5, -10);
      displayScreen.rotation.y = 0;
      
      scene.add(displayScreen);
      
      largeScreen = {
        screen: displayScreen,
        texture: screenTexture.texture,
        canvas: screenTexture.canvas
      };
      
      displayScreen.userData = {
        name: 'Large Display Screen',
        type: 'display',
        originalPosition: displayScreen.position.clone(),
        originalScale: displayScreen.scale.clone(),
        originalRotation: displayScreen.rotation.clone()
      };
      
      sceneObjects.push(displayScreen);
    }
    
    // Screen sharing and video functionality
    let currentStream = null;
    let currentVideo = null;

    // P2P Main Room functionality
    let socket = null;
    let peers = {};
    const MAIN_ROOM = 'MAIN_SHARED_ROOM';
    let inRoom = false;
    let roomUsers = [];
    
    // Simple P2P using BroadcastChannel for same-origin communication
    let broadcastChannel = null;
    let activeStreams = new Map(); // Track active streams from other tabs
    
    function initializeRoomSystem() {
      console.log('üöÄ Initializing WebRTC P2P with Cloudflare Worker signaling...');
      
      // Use Cloudflare Worker signaling server for live screen sharing
      const SIGNALING_SERVERS = [
        'https://screen-share-signaling.metamike.workers.dev',
        'https://test-worker.metamike.workers.dev'
      ];
      const SIGNALING_SERVER = SIGNALING_SERVERS[0];
      
      try {
        socket = io(SIGNALING_SERVER, {
          timeout: 5000,
          transports: ['polling', 'websocket']
        });
        
        socket.on('connect', () => {
          console.log('‚úÖ Connected to signaling server!');
          console.log('üéâ Real P2P screen sharing is now enabled!');
          
          // Auto-join the main room
          socket.emit('join-room', MAIN_ROOM);
        });
        
        socket.on('disconnect', () => {
          console.log('‚ùå Disconnected from signaling server');
        });
        
        // Handle room events
        socket.on('room-joined', (data) => {
          roomUsers = data.users || [];
          inRoom = true;
          console.log(`üè† Joined room! ${roomUsers.length} users online`);
          
          // Connect to existing users
          roomUsers.forEach(userId => {
            if (userId !== socket.id) {
              connectToPeer(userId, true); // We initiate
            }
          });
        });
        
        socket.on('user-joined', (data) => {
          console.log(`üëã New user joined: ${data.userId}`);
          connectToPeer(data.userId, false); // They initiate
        });
        
        socket.on('user-left', (data) => {
          console.log(`üëã User left: ${data.userId}`);
          if (peers[data.userId]) {
            peers[data.userId].destroy();
            delete peers[data.userId];
          }
        });
        
        socket.on('signal', (data) => {
          if (peers[data.from]) {
            peers[data.from].signal(data.signal);
          }
        });
        
      } catch (error) {
        console.error('‚ùå Failed to initialize P2P:', error);
        console.log('üí° Screen sharing will work locally only');
      }
    }
    
    
    function connectToPeer(userId, initiator, initialSignal = null) {
      const peer = new SimplePeer({
        initiator: initiator,
        trickle: false,
        stream: currentStream // Share current stream if available
      });
      
      peers[userId] = peer;
      
      peer.on('signal', (data) => {
        if (socket && socket.connected) {
          socket.emit('signal', {
            to: userId,
            signal: data
          });
        }
      });
      
      peer.on('stream', (stream) => {
        console.log('Received stream from peer');
        // Display received stream on the large screen
        displaySharedStream(stream);
      });
      
      peer.on('error', (err) => {
        console.error('Peer error:', err);
      });
      
      peer.on('close', () => {
        delete peers[userId];
      });
      
      peer.on('connect', () => {
        console.log('Peer connected:', userId);
        // If we have an active screen share, add it to the new peer
        if (currentStream && currentStream.active) {
          console.log('Adding existing screen share to new peer');
          peer.addStream(currentStream);
        }
      });
      
      if (initialSignal) {
        peer.signal(initialSignal);
      }
    }
    
    // Handle remote screen share from other tabs
    function handleRemoteScreenShare(data, senderId) {
      console.log('üîÑ Attempting to display remote screen share (limited by browser security)');
      
      // Note: BroadcastChannel can't transfer MediaStreams directly
      // This is a limitation - we can only sync the UI state, not the actual video
      
      // Show indicator that another tab is sharing
      const indicator = document.createElement('div');
      indicator.id = `remote-indicator-${senderId}`;
      indicator.style.cssText = `
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(0, 255, 0, 0.8);
        color: black;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        font-size: 14px;
      `;
      indicator.textContent = `üì∫ Another tab is sharing screen`;
      document.body.appendChild(indicator);
      
      // Update screen with message
      if (largeScreen && largeScreen.canvas) {
        const ctx = largeScreen.canvas.getContext('2d');
        ctx.fillStyle = '#001122';
        ctx.fillRect(0, 0, largeScreen.canvas.width, largeScreen.canvas.height);
        ctx.fillStyle = '#00ff00';
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Another Tab is Screen Sharing', largeScreen.canvas.width/2, largeScreen.canvas.height/2);
        ctx.font = '32px Arial';
        ctx.fillText('(BroadcastChannel limitation - can\'t share video)', largeScreen.canvas.width/2, largeScreen.canvas.height/2 + 50);
        largeScreen.texture.needsUpdate = true;
      }
    }
    
    function handleRemoteScreenStop(senderId) {
      const indicator = document.getElementById(`remote-indicator-${senderId}`);
      if (indicator) {
        indicator.remove();
      }
      
      // Reset screen content if no other remote shares
      if (!document.querySelector('[id^="remote-indicator-"]')) {
        resetScreenContent();
      }
    }
    
    function displaySharedStream(stream) {
      const videoEl = document.createElement('video');
      videoEl.srcObject = stream;
      videoEl.autoplay = true;
      videoEl.controls = true;
      videoEl.volume = 1.0; // Full volume
      videoEl.style.display = 'none';
      document.body.appendChild(videoEl);
      
      function updateScreenFromPeer() {
        if (videoEl.readyState >= videoEl.HAVE_CURRENT_DATA && largeScreen && largeScreen.canvas) {
          const ctx = largeScreen.canvas.getContext('2d');
          ctx.drawImage(videoEl, 0, 0, largeScreen.canvas.width, largeScreen.canvas.height);
          largeScreen.texture.needsUpdate = true;
        }
        
        if (stream.active) {
          requestAnimationFrame(updateScreenFromPeer);
        }
      }
      
      videoEl.addEventListener('loadeddata', () => {
        updateScreenFromPeer();
      });
    }
    
    
    
    async function startScreenShare() {
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: { width: { ideal: 1920 }, height: { ideal: 1080 } },
          audio: true
        });
        
        currentStream = stream;
        const videoEl = document.getElementById('video-element');
        videoEl.srcObject = stream;
        videoEl.muted = false; // Ensure screen sharing audio is not muted
        videoEl.volume = 1.0; // Set volume to maximum
        videoEl.play();
        
        function updateScreenTexture() {
          if (videoEl.readyState >= videoEl.HAVE_CURRENT_DATA && largeScreen && largeScreen.canvas) {
            const ctx = largeScreen.canvas.getContext('2d');
            ctx.drawImage(videoEl, 0, 0, largeScreen.canvas.width, largeScreen.canvas.height);
            largeScreen.texture.needsUpdate = true;
          }
          
          if (currentStream && currentStream.active) {
            requestAnimationFrame(updateScreenTexture);
          }
        }
        
        videoEl.addEventListener('loadeddata', () => updateScreenTexture());
        stream.getVideoTracks()[0].addEventListener('ended', () => stopScreenShare());
        
        // Share stream with all peers in shared room
        if (inRoom && Object.keys(peers).length > 0) {
          Object.values(peers).forEach(peer => {
            if (peer.connected) {
              peer.addStream(stream);
            }
          });
        }
        
        console.log('Screen sharing started');
        
        // Start broadcasting to Cloudflare Worker for all visitors
        startWorkerBroadcast();
        
        // Broadcast to other tabs
        if (broadcastChannel) {
          broadcastChannel.postMessage({
            type: 'screen-share-started',
            data: { streamId: 'local-stream' },
            senderId: 'local-user-' + Math.random().toString(36).substring(7)
          });
        }
        
      } catch (error) {
        console.error('Error starting screen share:', error);
        alert('Screen sharing failed. Please make sure you allow screen access.');
      }
    }
    
    function stopScreenShare() {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
        currentStream = null;
        document.getElementById('video-element').srcObject = null;
        resetScreenContent();
        console.log('Screen sharing stopped');
        
        // Stop broadcasting to Cloudflare Worker
        stopWorkerBroadcast();
        
        // Broadcast to other tabs
        if (broadcastChannel) {
          broadcastChannel.postMessage({
            type: 'screen-share-stopped',
            senderId: 'local-user'
          });
        }
      }
    }
    
    function loadVideoFile(file) {
      if (currentStream) stopScreenShare();
      
      const videoEl = document.getElementById('video-element');
      const url = URL.createObjectURL(file);
      videoEl.src = url;
      videoEl.loop = true;
      videoEl.muted = false; // Ensure audio is not muted
      videoEl.volume = 1.0; // Set volume to maximum
      videoEl.play();
      
      currentVideo = { file: file, url: url };
      
      function updateVideoTexture() {
        if (videoEl.readyState >= videoEl.HAVE_CURRENT_DATA && largeScreen && largeScreen.canvas) {
          const ctx = largeScreen.canvas.getContext('2d');
          ctx.drawImage(videoEl, 0, 0, largeScreen.canvas.width, largeScreen.canvas.height);
          largeScreen.texture.needsUpdate = true;
        }
        
        if (currentVideo && !videoEl.paused) {
          requestAnimationFrame(updateVideoTexture);
        }
      }
      
      videoEl.addEventListener('loadeddata', () => updateVideoTexture());
      videoEl.addEventListener('play', () => updateVideoTexture());
      
      console.log('Video loaded:', file.name);
    }
    
    function clearScreen() {
      if (currentStream) stopScreenShare();
      
      if (currentVideo) {
        const videoEl = document.getElementById('video-element');
        videoEl.pause();
        videoEl.src = '';
        URL.revokeObjectURL(currentVideo.url);
        currentVideo = null;
      }
      
      resetScreenContent();
    }
    
    function resetScreenContent() {
      if (!largeScreen || !largeScreen.canvas) {
        console.warn('Cannot reset screen content - largeScreen not ready');
        return;
      }
      
      const ctx = largeScreen.canvas.getContext('2d');
      ctx.fillStyle = '#001122';
      ctx.fillRect(0, 0, largeScreen.canvas.width, largeScreen.canvas.height);
      ctx.fillStyle = '#00ff00';
      
      // Scale font sizes based on canvas size for mobile compatibility
      const scale = largeScreen.canvas.width / 1920; // Scale relative to desktop size
      
      ctx.font = `bold ${Math.floor(72 * scale)}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText('LARGE DISPLAY SCREEN', largeScreen.canvas.width/2, largeScreen.canvas.height/2 - Math.floor(80 * scale));
      ctx.font = `bold ${Math.floor(48 * scale)}px Arial`;
      ctx.fillText('Ready for Screen Sharing or Video', largeScreen.canvas.width/2, largeScreen.canvas.height/2 + Math.floor(10 * scale));
      ctx.font = `${Math.floor(32 * scale)}px Arial`;
      ctx.fillText('Use controls to share desktop or load video', largeScreen.canvas.width/2, largeScreen.canvas.height/2 + Math.floor(80 * scale));
      
      largeScreen.texture.needsUpdate = true;
    }

    // Camera position - positioned at couch facing the screen (further back and slightly higher)
    camera.position.set(0, 2, -4);
    camera.lookAt(0, 2, -8);

    // Mobile controls
    let isMoving = false;
    let lastTap = 0;
    let cameraRotation = { x: 0, y: Math.PI };
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };

    // Screen dismissal functionality
    const screenElement = document.getElementById('interactive-screen');
    const dragOverlay = document.getElementById('drag-overlay');
    const modelControls = document.getElementById('model-controls');

    function hideScreen() {
      if (isScreenVisible) {
        screenElement.style.display = 'none';
        isScreenVisible = false;
      }
    }

    screenElement.addEventListener('click', hideScreen);

    // Object selection functions
    function checkObjectSelection(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(sceneObjects, true);
      
      if (intersects.length > 0) {
        let targetObject = intersects[0].object;
        
        while (targetObject.parent && !sceneObjects.includes(targetObject)) {
          targetObject = targetObject.parent;
        }
        
        if (sceneObjects.includes(targetObject)) {
          selectObject(targetObject);
        }
      } else {
        deselectObject();
      }
    }
    
    function selectObject(object) {
      if (selectedObject) clearSelection();
      
      selectedObject = object;
      addSelectionIndicator(object);
      modelControls.classList.add('visible');
      document.getElementById('selected-object-name').textContent = object.userData.name || 'Unknown Object';
    }
    
    function deselectObject() {
      if (selectedObject) {
        clearSelection();
        selectedObject = null;
        modelControls.classList.remove('visible');
      }
    }
    
    function clearSelection() {
      if (selectedOutline) {
        scene.remove(selectedOutline);
        selectedOutline = null;
      }
    }
    
    function addSelectionIndicator(object) {
      const geometry = object.geometry;
      if (geometry) {
        const wireframe = new THREE.WireframeGeometry(geometry);
        const outlineMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 3 });
        selectedOutline = new THREE.LineSegments(wireframe, outlineMaterial);
        
        selectedOutline.position.copy(object.position);
        selectedOutline.rotation.copy(object.rotation);
        selectedOutline.scale.copy(object.scale);
        
        scene.add(selectedOutline);
      }
    }

    // Object manipulation functions
    window.moveObject = function(direction) {
      if (!selectedObject) return;
      
      const moveAmount = 0.5;
      
      switch(direction) {
        case 'up': selectedObject.position.y += moveAmount; break;
        case 'down': selectedObject.position.y -= moveAmount; break;
        case 'left': selectedObject.position.x -= moveAmount; break;
        case 'right': selectedObject.position.x += moveAmount; break;
        case 'forward': selectedObject.position.z -= moveAmount; break;
        case 'backward': selectedObject.position.z += moveAmount; break;
      }
      
      if (selectedOutline) {
        selectedOutline.position.copy(selectedObject.position);
      }
    };

    window.scaleObject = function(direction) {
      if (!selectedObject) return;
      
      const scaleAmount = direction === 'up' ? 1.1 : 0.9;
      selectedObject.scale.multiplyScalar(scaleAmount);
      
      if (selectedOutline) {
        selectedOutline.scale.copy(selectedObject.scale);
      }
    };

    window.rotateObject = function(axis) {
      if (!selectedObject) return;
      
      if (axis === 'y') {
        selectedObject.rotation.y += Math.PI / 4;
      }
      
      if (selectedOutline) {
        selectedOutline.rotation.copy(selectedObject.rotation);
      }
    };

    window.resetObject = function() {
      if (!selectedObject || !selectedObject.userData) return;
      
      const userData = selectedObject.userData;
      selectedObject.position.copy(userData.originalPosition);
      selectedObject.scale.copy(userData.originalScale);
      selectedObject.rotation.copy(userData.originalRotation);
      
      if (userData.originalColor && selectedObject.material) {
        selectedObject.material.color.setHex(userData.originalColor);
        selectedObject.material.emissive.setHex(0x000000);
      }
      
      if (selectedOutline) {
        selectedOutline.position.copy(selectedObject.position);
        selectedOutline.scale.copy(selectedObject.scale);
        selectedOutline.rotation.copy(selectedObject.rotation);
      }
    };
    
    window.deleteSelected = function() {
      if (!selectedObject) return;
      
      scene.remove(selectedObject);
      
      const index = sceneObjects.indexOf(selectedObject);
      if (index > -1) {
        sceneObjects.splice(index, 1);
      }
      
      deselectObject();
    };
    
    window.deselectObject = deselectObject;

    // Touch controls for mobile
    document.addEventListener('touchstart', (event) => {
      if (event.touches.length === 1) {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        
        if (tapLength < 500 && tapLength > 0) {
          isMoving = true;
          moveForward();
        }
        lastTap = currentTime;
        
        isDragging = true;
        previousMousePosition = {
          x: event.touches[0].clientX,
          y: event.touches[0].clientY
        };
      }
      event.preventDefault();
    });

    document.addEventListener('touchmove', (event) => {
      if (isDragging && event.touches.length === 1) {
        const deltaMove = {
          x: event.touches[0].clientX - previousMousePosition.x,
          y: event.touches[0].clientY - previousMousePosition.y
        };
        
        cameraRotation.y -= deltaMove.x * 0.005;
        cameraRotation.x -= deltaMove.y * 0.005;
        cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
        
        previousMousePosition = {
          x: event.touches[0].clientX,
          y: event.touches[0].clientY
        };
      }
      event.preventDefault();
    });

    document.addEventListener('touchend', (event) => {
      isMoving = false;
      isDragging = false;
      event.preventDefault();
    });

    // Mouse controls for desktop
    document.addEventListener('mousedown', (event) => {
      if (event.target.closest('.model-controls') || event.target.closest('.controls-info') || event.target.closest('.screen-controls')) {
        return;
      }
      
      isDragging = true;
      previousMousePosition = { x: event.clientX, y: event.clientY };
      
      if (!isScreenVisible) {
        checkObjectSelection(event);
      }
    });

    document.addEventListener('mousemove', (event) => {
      if (isDragging) {
        const deltaMove = {
          x: event.clientX - previousMousePosition.x,
          y: event.clientY - previousMousePosition.y
        };
        
        cameraRotation.y -= deltaMove.x * 0.005;
        cameraRotation.x -= deltaMove.y * 0.005;
        cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
        
        previousMousePosition = { x: event.clientX, y: event.clientY };
      }
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    // Keyboard controls
    const keys = {};
    document.addEventListener('keydown', (event) => {
      keys[event.code] = true;
      
      if (event.code === 'Enter' && isScreenVisible) {
        hideScreen();
        return;
      }
      
      if (!isScreenVisible && selectedObject) {
        switch(event.code) {
          case 'KeyR': resetObject(); break;
          case 'KeyQ': rotateObject('y'); break;
          case 'KeyE': scaleObject('up'); break;
          case 'KeyC': scaleObject('down'); break;
          case 'Delete':
          case 'Backspace': deleteSelected(); break;
          case 'Escape': deselectObject(); break;
        }
      }
    });

    document.addEventListener('keyup', (event) => {
      keys[event.code] = false;
    });

    function moveForward() {
      if (isMoving) {
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(camera.quaternion);
        camera.position.add(direction.multiplyScalar(0.1));
        requestAnimationFrame(moveForward);
      }
    }

    // Drag and drop functionality
    let dragCounter = 0;

    document.addEventListener('dragenter', (e) => {
      e.preventDefault();
      dragCounter++;
      if (dragCounter === 1) {
        dragOverlay.classList.add('active');
      }
    });

    document.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dragCounter--;
      if (dragCounter === 0) {
        dragOverlay.classList.remove('active');
      }
    });

    document.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    document.addEventListener('drop', (e) => {
      e.preventDefault();
      dragCounter = 0;
      dragOverlay.classList.remove('active');
      
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const file = files[0];
        if (file.name.toLowerCase().endsWith('.glb') || file.name.toLowerCase().endsWith('.gltf')) {
          hideScreen();
          loadModelFromFile(file);
        } else {
          alert('Please drop a GLB or GLTF file');
        }
      }
    });

    // GLTF Loader
    const loader = new GLTFLoader();
    
    // Load the room model after loader is initialized
    loadRoomModel();

    function loadModelFromFile(file) {
      const url = URL.createObjectURL(file);
      
      loader.load(url, function(gltf) {
        const model = gltf.scene;
        
        model.position.set(0, -1, -3);
        model.scale.set(1, 1, 1);
        
        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        
        model.userData = {
          name: file.name.replace('.glb', '').replace('.gltf', ''),
          type: 'model',
          originalPosition: new THREE.Vector3(0, -1, -3),
          originalScale: new THREE.Vector3(1, 1, 1),
          originalRotation: new THREE.Euler(0, 0, 0)
        };
        
        scene.add(model);
        sceneObjects.push(model);
        selectObject(model);
        
        URL.revokeObjectURL(url);
        console.log('Model loaded successfully:', file.name);
      }, 
      function(progress) {
        console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
      },
      function(error) {
        console.error('Error loading model:', error);
        alert('Error loading model: ' + error.message);
      });
    }

    // Handle window resize
    // Research-backed resize handling for mobile compatibility
    function onWindowResize() {
      // Mobile-safe sizing
      const width = isMobile ? Math.min(window.innerWidth, 1024) : window.innerWidth;
      const height = isMobile ? Math.min(window.innerHeight, 1024) : window.innerHeight;
      
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      
      if (composer) {
        composer.setSize(width, height);
      }
      
      console.log('Resized to:', width, 'x', height, 'Mobile:', isMobile);
    }
    
    window.addEventListener('resize', onWindowResize);

    // Animation loop with context loss tracking
    function animate() {
      window.animationId = requestAnimationFrame(animate);
      
      camera.rotation.order = 'YXZ';
      camera.rotation.y = cameraRotation.y;
      camera.rotation.x = cameraRotation.x;
      
      const moveSpeed = 0.1;
      if (keys['KeyW'] || keys['ArrowUp']) {
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(camera.quaternion);
        camera.position.add(direction.multiplyScalar(moveSpeed));
      }
      if (keys['KeyS'] || keys['ArrowDown']) {
        const direction = new THREE.Vector3(0, 0, 1);
        direction.applyQuaternion(camera.quaternion);
        camera.position.add(direction.multiplyScalar(moveSpeed));
      }
      if (keys['KeyA'] || keys['ArrowLeft']) {
        const direction = new THREE.Vector3(-1, 0, 0);
        direction.applyQuaternion(camera.quaternion);
        camera.position.add(direction.multiplyScalar(moveSpeed));
      }
      if (keys['KeyD'] || keys['ArrowRight']) {
        const direction = new THREE.Vector3(1, 0, 0);
        direction.applyQuaternion(camera.quaternion);
        camera.position.add(direction.multiplyScalar(moveSpeed));
      }
      
      
      // Mobile-optimized rendering with explicit clearing
      if (isMobile) {
        // Explicit clear for mobile compatibility
        renderer.clear(true, true, true);
        // Force immediate render without composer
        renderer.render(scene, camera);
      } else if (composer) {
        composer.render();
      } else {
        renderer.render(scene, camera);
      }
    }

    // Add event listeners for control buttons
    ['move-up', 'move-down', 'move-left', 'move-right', 'move-forward', 'move-backward'].forEach(id => {
      document.getElementById(id).addEventListener('click', (e) => {
        e.stopPropagation();
        moveObject(id.split('-')[1]);
      });
    });
    
    ['scale-up', 'scale-down'].forEach(id => {
      document.getElementById(id).addEventListener('click', (e) => {
        e.stopPropagation();
        scaleObject(id.split('-')[1]);
      });
    });
    
    document.getElementById('rotate-y').addEventListener('click', (e) => {
      e.stopPropagation();
      rotateObject('y');
    });
    
    document.getElementById('reset-object').addEventListener('click', (e) => {
      e.stopPropagation();
      resetObject();
    });
    
    document.getElementById('delete-selected').addEventListener('click', (e) => {
      e.stopPropagation();
      deleteSelected();
    });
    
    document.getElementById('deselect-object').addEventListener('click', (e) => {
      e.stopPropagation();
      deselectObject();
    });

    // Screen control event listeners
    document.getElementById('share-screen').addEventListener('click', (e) => {
      e.stopPropagation();
      startScreenShare();
    });
    
    document.getElementById('stop-sharing').addEventListener('click', (e) => {
      e.stopPropagation();
      stopScreenShare();
    });
    
    document.getElementById('video-upload').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        loadVideoFile(file);
      }
    });
    
    document.getElementById('load-video').addEventListener('click', (e) => {
      e.stopPropagation();
      document.getElementById('video-upload').click();
    });
    
    document.getElementById('clear-screen').addEventListener('click', (e) => {
      e.stopPropagation();
      clearScreen();
    });

    // Audio control event listeners
    let isAudioMuted = false;
    document.getElementById('toggle-audio').addEventListener('click', (e) => {
      e.stopPropagation();
      const videoEl = document.getElementById('video-element');
      const button = document.getElementById('toggle-audio');
      
      isAudioMuted = !isAudioMuted;
      videoEl.muted = isAudioMuted;
      
      // Also update all peer video elements
      document.querySelectorAll('video').forEach(video => {
        video.muted = isAudioMuted;
      });
      
      button.textContent = isAudioMuted ? 'üîá Audio OFF' : 'üîä Audio ON';
      console.log('Audio ' + (isAudioMuted ? 'muted' : 'unmuted'));
    });
    
    document.getElementById('volume-slider').addEventListener('input', (e) => {
      const volume = e.target.value / 100;
      const videoEl = document.getElementById('video-element');
      videoEl.volume = volume;
      
      // Also update all peer video elements
      document.querySelectorAll('video').forEach(video => {
        video.volume = volume;
      });
      
      console.log('Volume set to:', Math.round(volume * 100) + '%');
    });


    // Cloudflare Worker broadcast system for live screen sharing
    const WORKER_URL = 'https://screen-share-signaling.metamike.workers.dev';
    let workerWebSocket = null;
    let isSharer = false;
    let broadcastInterval = null;
    
    // Initialize Worker WebSocket connection for receiving broadcasts
    function initializeWorkerConnection() {
      try {
        const wsUrl = WORKER_URL.replace('https://', 'wss://');
        workerWebSocket = new WebSocket(wsUrl);
        
        workerWebSocket.onopen = () => {
          console.log('‚úÖ Connected to Cloudflare Worker for live screen sharing!');
        };
        
        workerWebSocket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            handleWorkerMessage(data);
          } catch (error) {
            console.error('Error parsing Worker message:', error);
          }
        };
        
        workerWebSocket.onclose = () => {
          console.log('‚ùå Disconnected from Worker. Attempting reconnection in 5s...');
          setTimeout(initializeWorkerConnection, 5000);
        };
        
        workerWebSocket.onerror = (error) => {
          console.error('Worker WebSocket error:', error);
        };
        
      } catch (error) {
        console.error('Failed to connect to Worker:', error);
        console.log('üí° Live screen sharing may not work without Worker connection');
      }
    }
    
    // Handle messages from Cloudflare Worker
    function handleWorkerMessage(data) {
      switch (data.type) {
        case 'frame':
          if (!isSharer && largeScreen && largeScreen.canvas) {
            displayWorkerFrame(data);
          }
          break;
        case 'stop':
          resetScreenContent();
          break;
      }
    }
    
    // Display frame received from Worker
    function displayWorkerFrame(messageData) {
      try {
        const frameData = messageData.frame?.data || messageData.data;
        if (!frameData) return;
        
        const img = new Image();
        img.onload = () => {
          if (largeScreen && largeScreen.canvas) {
            const ctx = largeScreen.canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, largeScreen.canvas.width, largeScreen.canvas.height);
            largeScreen.texture.needsUpdate = true;
          }
        };
        img.src = frameData;
      } catch (error) {
        console.error('Error displaying Worker frame:', error);
      }
    }
    
    // Start broadcasting screen frames to Worker
    function startWorkerBroadcast() {
      if (broadcastInterval) return;
      
      isSharer = true;
      console.log('üöÄ Starting live broadcast to all site visitors...');
      
      broadcastInterval = setInterval(() => {
        if (largeScreen && largeScreen.canvas && currentStream && currentStream.active) {
          try {
            const frameData = largeScreen.canvas.toDataURL('image/jpeg', 0.8);
            
            fetch(`${WORKER_URL}/broadcast`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                frameData: frameData,
                width: largeScreen.canvas.width,
                height: largeScreen.canvas.height
              })
            }).catch(error => {
              console.error('Error sending frame to Worker:', error);
            });
          } catch (error) {
            console.error('Error capturing frame for broadcast:', error);
          }
        }
      }, 100); // Send frame every 100ms (10 FPS)
    }
    
    // Stop broadcasting to Worker
    function stopWorkerBroadcast() {
      if (broadcastInterval) {
        clearInterval(broadcastInterval);
        broadcastInterval = null;
      }
      
      isSharer = false;
      
      // Notify Worker to stop sharing
      fetch(`${WORKER_URL}/stop`, {
        method: 'POST'
      }).catch(error => {
        console.error('Error stopping Worker broadcast:', error);
      });
      
      console.log('üõë Stopped live broadcast');
    }
    
    // Get current screen frame for new visitors
    async function loadCurrentWorkerFrame() {
      try {
        const response = await fetch(`${WORKER_URL}/current`);
        const data = await response.json();
        
        if (data.active && data.frame && !isSharer) {
          displayWorkerFrame({ data: data.frame });
          console.log('üì∫ Loaded current screen share from Worker');
        }
      } catch (error) {
        console.error('Error loading current frame:', error);
      }
    }

    // Initialize both room system and Worker connection
    initializeRoomSystem();
    initializeWorkerConnection();
    
    // Load current frame on page load
    setTimeout(loadCurrentWorkerFrame, 2000);

    // Start the animation loop
    // Final mobile compatibility check before starting animation
    console.log('=== FINAL RENDER CHECK ===');
    console.log('Renderer ready:', !!renderer);
    console.log('Scene objects:', scene.children.length);
    console.log('Camera position:', camera.position);
    console.log('WebGL context valid:', !renderer.getContext().isContextLost());
    
    // Start animation with error handling
    try {
      animate();
      console.log('Animation loop started successfully');
    } catch (error) {
      console.error('Failed to start animation:', error);
      // Fallback: try to render one frame
      try {
        renderer.render(scene, camera);
        console.log('Single frame render successful');
      } catch (renderError) {
        console.error('Render failed completely:', renderError);
        document.body.innerHTML += '<div style="color: red; position: fixed; top: 10px; left: 10px;">Render Error: ' + renderError.message + '</div>';
      }
    }

    console.log('3D Interactive Website loaded successfully!');
  </script>
</body>
</html>